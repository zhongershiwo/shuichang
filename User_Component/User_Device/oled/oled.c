/*
 * oled.c
 *
 *  Created on: 2017年9月24日
 *      Author: 惠普
 */

#include "oled.h"

extern uint8_t Image[64][128];
int Temp_List[128];
signed int Mid_Line;
unsigned char Result[Cross/8][Row];
union                                   // 转换结果
{
  unsigned char Paint_Buffer[Cross/8] [Row];
}_Paint_;

#define Paint_Buffer          _Paint_.Paint_Buffer

const unsigned char Change_To_Bit[8]=
{
  0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01
};

const unsigned char Change_To_Bit_2[8]=
{
  0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80//01 10 100 1000
};
/******************************************************/
/********************  外部调用    ********************/
/******************************************************/


/******************************************************/
/********************  OLED函数    ********************/
/******************************************************/

#define X_WIDTH 128
#define Y_WIDTH 64
/******************************************************/
/*******************  ASCII码字库    ******************/
/******************************************************/


unsigned char Draw[]=
{
  0xfc,0x04,0x07,0x01,0x01,0x07,0x04,0xfc,0xff,0x80,0x80,0x80,0x80,0x80,0x80,0xff,//没电 0
  0xfc,0x04,0x07,0x01,0x01,0x07,0x04,0xfc,0xff,0x80,0xa0,0xa0,0xa0,0xa0,0x80,0xff,//一格 1
  0xfc,0x04,0x07,0x01,0x01,0x07,0x04,0xfc,0xff,0x80,0xb0,0xb0,0xb0,0xb0,0x80,0xff,//两格 2
  0xfc,0x04,0x07,0x01,0x01,0x07,0x04,0xfc,0xff,0x80,0xb8,0xb8,0xb8,0xb8,0x80,0xff,//三格 3
  0xfc,0x04,0x07,0x01,0x01,0x07,0x04,0xfc,0xff,0x80,0xbc,0xbc,0xbc,0xbc,0x80,0xff,//四格 4
  0xfc,0x04,0x07,0x01,0x01,0x07,0x04,0xfc,0xff,0x80,0xbe,0xbe,0xbe,0xbe,0x80,0xff,//五格 5
  0xfc,0x04,0x07,0x01,0x01,0x07,0x04,0xfc,0xff,0x80,0xbf,0xbf,0xbf,0xbf,0x80,0xff,//六格 6
  0xfc,0x04,0x87,0x81,0x81,0x87,0x04,0xfc,0xff,0x80,0xbf,0xbf,0xbf,0xbf,0x80,0xff,//七格 7
  0xfc,0x04,0xc7,0xc1,0xc1,0xc7,0x04,0xfc,0xff,0x80,0xbf,0xbf,0xbf,0xbf,0x80,0xff,//八格 8
  0xfc,0x04,0xe7,0xe1,0xe1,0xe7,0x04,0xfc,0xff,0x80,0xbf,0xbf,0xbf,0xbf,0x80,0xff,//九格 9
  0xfc,0x04,0xf7,0xf1,0xf1,0xf7,0x04,0xfc,0xff,0x80,0xbf,0xbf,0xbf,0xbf,0x80,0xff,//十格10
  0x00,0xFC,0xF8,0xF0,0xE0,0xC0,0x80,0x00,0x00,0x0F,0x07,0x07,0x1F,0x3F,0x19,0x01,//箭头11
  0x00,0xF8,0x04,0x04,0x04,0x04,0x38,0x00,0x00,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x00,//开锁12
  0x00,0xE0,0x10,0x10,0x10,0x10,0xE0,0x00,0x00,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x00,//闭锁13
  0x00,0x00,0x00,0xFC,0xFC,0x18,0x18,0x00,0x00,0x3C,0x7E,0x67,0x67,0x7E,0x3C,0x00,//钥匙14
  0xc0,0x60,0x30,0x18,0x18,0x30,0x60,0xc0,0x01,0x01,0x1f,0x10,0x10,0x1f,0x01,0x01,//上档15
  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//黑块16
  0xff,0x01,0x01,0x01,0x01,0x01,0x01,0xff,0xff,0x80,0x80,0x80,0x80,0x80,0x80,0xff,//方框17
  0xC0,0xC0,0xC0,0xC0,0xF0,0xE0,0xC0,0x80,0x01,0x01,0x01,0x01,0x07,0x03,0x01,0x00,//右箭头18
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//空白19
  0x00,0x00,0xF8,0xF8,0xF8,0xF8,0x00,0x00,0x01,0x03,0x07,0x0F,0x0F,0x07,0x03,0x01,//下箭头20
  0x40,0xA0,0xD0,0x68,0x68,0xD0,0xA0,0x40,0x22,0x25,0x2B,0x36,0x36,0x2B,0x25,0x22,//轮子21
  0xE0,0xE0,0xE0,0xE0,0xF8,0xF0,0xE0,0x40,0x00,0x00,0x00,0x00,0x03,0x01,0x00,0x00,//22 箭头
  0x00,0xE8,0xA8,0xBE,0xA8,0xE8,0x00,0x00,0x20,0x3F,0x2A,0x2A,0x2A,0x3F,0x20,0x00,//23 汉字：直
  0xD0,0xB0,0xDC,0x90,0x40,0xD0,0x7C,0x50,0x08,0x04,0x1F,0x00,0x05,0x0D,0x13,0x01,//24 汉字 转
  0x20,0x90,0x98,0x14,0x12,0x10,0x20,0xC0,0x20,0x20,0x10,0x09,0x02,0x10,0x20,0x3F,//25 汉字 匀

};



/******************************************************/
/*******************  ASCII码字库    ******************/
/******************************************************/

const unsigned char Font_8x16[1520]=
{
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//  0
  0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x30,0x00,0x00,0x00,//! 1
  0x00,0x10,0x0C,0x06,0x10,0x0C,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//" 2
  0x40,0xC0,0x78,0x40,0xC0,0x78,0x40,0x00,0x04,0x3F,0x04,0x04,0x3F,0x04,0x04,0x00,//# 3
  0x00,0x70,0x88,0xFC,0x08,0x30,0x00,0x00,0x00,0x18,0x20,0xFF,0x21,0x1E,0x00,0x00,//$ 4
  0xF0,0x08,0xF0,0x00,0xE0,0x18,0x00,0x00,0x00,0x21,0x1C,0x03,0x1E,0x21,0x1E,0x00,//% 5
  0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,0x1E,0x21,0x23,0x24,0x19,0x27,0x21,0x10,//& 6
  0x10,0x16,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//' 7
  0x00,0x00,0x00,0xE0,0x18,0x04,0x02,0x00,0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x00,//( 8
  0x00,0x02,0x04,0x18,0xE0,0x00,0x00,0x00,0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00,//) 9
  0x40,0x40,0x80,0xF0,0x80,0x40,0x40,0x00,0x02,0x02,0x01,0x0F,0x01,0x02,0x02,0x00,//* 10
  0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x1F,0x01,0x01,0x01,0x00,//+ 11
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xB0,0x70,0x00,0x00,0x00,0x00,0x00,//, 12
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,//- 13
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00,//. 14
  0x00,0x00,0x00,0x00,0x80,0x60,0x18,0x04,0x00,0x60,0x18,0x06,0x01,0x00,0x00,0x00,/// 15
  0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00,//0 16
  0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//1 17
  0x00,0x70,0x08,0x08,0x08,0x88,0x70,0x00,0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00,//2 18
  0x00,0x30,0x08,0x88,0x88,0x48,0x30,0x00,0x00,0x18,0x20,0x20,0x20,0x11,0x0E,0x00,//3 19
  0x00,0x00,0xC0,0x20,0x10,0xF8,0x00,0x00,0x00,0x07,0x04,0x24,0x24,0x3F,0x24,0x00,//4 20
  0x00,0xF8,0x08,0x88,0x88,0x08,0x08,0x00,0x00,0x19,0x21,0x20,0x20,0x11,0x0E,0x00,//5 21
  0x00,0xE0,0x10,0x88,0x88,0x18,0x00,0x00,0x00,0x0F,0x11,0x20,0x20,0x11,0x0E,0x00,//6 22
  0x00,0x38,0x08,0x08,0xC8,0x38,0x08,0x00,0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00,//7 23
  0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00,//8 24
  0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x00,0x31,0x22,0x22,0x11,0x0F,0x00,//9 25
  0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,//: 26
  0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x60,0x00,0x00,0x00,0x00,//; 27
  0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00,//< 28
  0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00,//= 29
  0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x00,//> 30
  0x00,0x70,0x48,0x08,0x08,0x08,0xF0,0x00,0x00,0x00,0x00,0x30,0x36,0x01,0x00,0x00,//? 31
  0xC0,0x30,0xC8,0x28,0xE8,0x10,0xE0,0x00,0x07,0x18,0x27,0x24,0x23,0x14,0x0B,0x00,//@ 32
  0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20,//A 33
  0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00,//B 34
  0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00,//C 35
  0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00,//D 36
  0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00,//E 37
  0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00,//F 38
  0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00,//G 39
  0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20,//H 40
  0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//I 41
  0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00,//J 42
  0x08,0xF8,0x88,0xC0,0x28,0x18,0x08,0x00,0x20,0x3F,0x20,0x01,0x26,0x38,0x20,0x00,//K 43
  0x08,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x20,0x30,0x00,//L 44
  0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,0x20,0x3F,0x00,0x3F,0x00,0x3F,0x20,0x00,//M 45
  0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00,//N 46
  0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00,//O 47
  0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00,//P 48
  0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x18,0x24,0x24,0x38,0x50,0x4F,0x00,//Q 49
  0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20,//R 50
  0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00,//S 51
  0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,//T 52
  0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,//U 53
  0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00,//V 54
  0xF8,0x08,0x00,0xF8,0x00,0x08,0xF8,0x00,0x03,0x3C,0x07,0x00,0x07,0x3C,0x03,0x00,//W 55
  0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20,//X 56
  0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,//Y 57
  0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00,//Z 58
  0x00,0x00,0x00,0xFE,0x02,0x02,0x02,0x00,0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x00,//[ 59
  0x00,0x0C,0x30,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x38,0xC0,0x00,//\ 60
  0x00,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,0x00,0x40,0x40,0x40,0x7F,0x00,0x00,0x00,//] 61
  0x00,0x00,0x04,0x02,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//^ 62
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,//_ 63
  0x00,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//` 64
  0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x19,0x24,0x22,0x22,0x22,0x3F,0x20,//a 65
  0x08,0xF8,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x3F,0x11,0x20,0x20,0x11,0x0E,0x00,//b 66
  0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x00,//c 67
  0x00,0x00,0x00,0x80,0x80,0x88,0xF8,0x00,0x00,0x0E,0x11,0x20,0x20,0x10,0x3F,0x20,//d 68
  0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x22,0x22,0x22,0x22,0x13,0x00,//e 69
  0x00,0x80,0x80,0xF0,0x88,0x88,0x88,0x18,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//f 70
  0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x6B,0x94,0x94,0x94,0x93,0x60,0x00,//g 71
  0x08,0xF8,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,//h 72
  0x00,0x80,0x98,0x98,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//i 73
  0x00,0x00,0x00,0x80,0x98,0x98,0x00,0x00,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,//j 74
  0x08,0xF8,0x00,0x00,0x80,0x80,0x80,0x00,0x20,0x3F,0x24,0x02,0x2D,0x30,0x20,0x00,//k 75
  0x00,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//l 76
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F,//m 77
  0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,//n 78
  0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,//o 79
  0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,0x80,0xFF,0xA1,0x20,0x20,0x11,0x0E,0x00,//p 80
  0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x0E,0x11,0x20,0x20,0xA0,0xFF,0x80,//q 81
  0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00,//r 82
  0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x33,0x24,0x24,0x24,0x24,0x19,0x00,//s 83
  0x00,0x80,0x80,0xE0,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x1F,0x20,0x20,0x00,0x00,//t 84
  0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20,//u 85
  0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x00,0x01,0x0E,0x30,0x08,0x06,0x01,0x00,//v 86
  0x80,0x80,0x00,0x80,0x00,0x80,0x80,0x80,0x0F,0x30,0x0C,0x03,0x0C,0x30,0x0F,0x00,//w 87
  0x00,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x31,0x2E,0x0E,0x31,0x20,0x00,//x 88
  0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x80,0x81,0x8E,0x70,0x18,0x06,0x01,0x00,//y 89
  0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x21,0x30,0x2C,0x22,0x21,0x30,0x00,//z 90
  0x00,0x00,0x00,0x00,0x80,0x7C,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x3F,0x40,0x40,//{ 91
  0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,//| 92
  0x00,0x02,0x02,0x7C,0x80,0x00,0x00,0x00,0x00,0x40,0x40,0x3F,0x00,0x00,0x00,0x00,//} 93
  0x00,0x06,0x01,0x01,0x02,0x02,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//~ 94
};

LDD_TDeviceDataPtr  myoledscl;
LDD_TDeviceDataPtr  myoledsda;
LDD_TDeviceDataPtr  myoledrst;
LDD_TDeviceDataPtr  myoleddc;


#define SCL_LOW()  Oled_D0_PutVal(myoledscl,0)
#define SCL_HIGH() Oled_D0_PutVal(myoledscl,1)
#define SDA_LOW()  Oled_D1_PutVal(myoledsda,0)
#define SDA_HIGH() Oled_D1_PutVal(myoledsda,1)
#define RST_LOW()  Oled_Rst_PutVal(myoleddc,0)
#define RST_HIGH() Oled_Rst_PutVal(myoleddc,1)
#define DC_LOW()   Oled_DC_PutVal(myoleddc,0)
#define DC_HIGH()  Oled_DC_PutVal(myoleddc,1)

void OLED_IO_Init(void)
{
	myoledscl = Oled_D0_Init(NULL);  //PTA13
	myoledsda = Oled_D1_Init(NULL);  //PTA14
	myoledrst = Oled_Rst_Init(NULL);  //PTA5
	myoleddc  = Oled_DC_Init(NULL);  //PTA12
}


/*--------------------*OLED写数据*--------------------*/

void OLED_Write_Data(unsigned char Data)
{
  unsigned char Temp_i=8;
  DC_HIGH();  //DC_High=1;
  SCL_LOW();  //OLED_SCL=0;
  while(Temp_i--)
  {
    if(Data&0x80)
    {
    	SDA_HIGH();  //OLED_SDA=1;
    }
    else
    {
    	SDA_LOW();  //OLED_SDA=0;
    }
    SCL_HIGH();  //OLED_SCL=1;
    asm("nop");
    SCL_LOW(); //OLED_SCL=0;;
    Data<<=1;
  }
}

/*--------------------*OLED写命令*--------------------*/

void OLED_Write_Command(unsigned char Cmd)
{
	unsigned char Temp_i=8;

    DC_LOW();  //OLED_DC=0;;
    SCL_LOW();  //OLED_SCL=0;;
    while(Temp_i--)
    {
    	if(Cmd&0x80)
    	{
    		SDA_HIGH(); //OLED_SDA=1;
    	}
        else
        {
        	SDA_LOW();  //OLED_SDA=0;;
        }
        SCL_HIGH();  //OLED_SCL=1;;
        asm("nop");;
        SCL_LOW();  //OLED_SCL=0;;
        Cmd<<=1;;
    }
}

/*-------------------*整型转字符串*-------------------*/

void OLED_Set_Pos(unsigned char x,unsigned char y)
{
  OLED_Write_Command(0xb0+y);
  OLED_Write_Command(((x&0xf0)>>4)|0x10);
  OLED_Write_Command(x&0x0f);
}

/*-------------------*整型转字符串*-------------------*/

void OLED_Fill(unsigned char Bmp_data)
{
	unsigned char y,x;

	for(y=0;y<8;y++)
	{
		OLED_Write_Command(0xb0+y);
		OLED_Write_Command(0x01);
		OLED_Write_Command(0x10);
		for(x=0;x<X_WIDTH;x++)
			OLED_Write_Data(Bmp_data);
	}
}

/*---------------------*OLED清屏*---------------------*/

void OLED_Clear(void)
// 全部写上0
{
	OLED_Fill(0x00);
}

/*--------------------*OLED初始化*--------------------*/

void OLED_Init(void)
{
	unsigned int Temp_Count;

    OLED_IO_Init();
	SCL_HIGH();  //OLED_SCL=1;
	RST_LOW();  //OLED_RST=0;
	for(Temp_Count=0;Temp_Count<50000;Temp_Count++);
	RST_HIGH();   //OLED_RST=1;
	//从上电到下面开始初始化要有足够的时间，即等待RC复位完毕
    OLED_Write_Command(0xAE|0x00);			                // Display Off (0x00/0x01)
    OLED_Write_Command(0xD5);OLED_Write_Command(0x80);	// Set Clock as 100 Frames/Sec
    OLED_Write_Command(0xA8);OLED_Write_Command(0x3F);	// 1/64 Duty (0x0F~0x3F)
    OLED_Write_Command(0xD3);OLED_Write_Command(0x00);	// Shift Mapping RAM Counter (0x00~0x3F)
    OLED_Write_Command(0x40|0x00);			                // Set Mapping RAM Display Start Line (0x00~0x3F)
    OLED_Write_Command(0x8D);OLED_Write_Command(0x10|0x04);	    // Enable Embedded DC/DC Converter (0x00/0x04)
    OLED_Write_Command(0x20);OLED_Write_Command(0x02);		      // Set Page Addressing Mode (0x00/0x01/0x02)
    OLED_Write_Command(0xA0|0x01);                      // Set SEG/Column Mapping     0x00左右反置 0x01正常
    OLED_Write_Command(0xC0|0x08);			                // Set COM/Row Scan Direction 0x00上下反置 0x08正常
    OLED_Write_Command(0xDA);OLED_Write_Command(0x02|0x10);	    // Set Sequential Configuration (0x00/0x10)
    OLED_Write_Command(0x81);OLED_Write_Command(0xCF);	  // Set SEG Output Current
    OLED_Write_Command(0xD9);OLED_Write_Command(0xF1);	        // Set Pre-Charge as 15 Clocks & Discharge as 1 Clock
    OLED_Write_Command(0xDB);OLED_Write_Command(0x40);			    // Set VCOM Deselect Level
    OLED_Write_Command(0xA4|0x00);		                  // Disable Entire Display On (0x00/0x01)
    OLED_Write_Command(0xA6|0x00);		                  // Disable Inverse Display On (0x00/0x01)
    OLED_Write_Command(0xAE|0x01);		                  // Display On (0x00/0x01)
    OLED_Clear();                                       // 初始清屏
	OLED_Set_Pos(0,0);
}

/*-------------------*整型转字符串*-------------------*/

signed int Int_To_String(signed long Int_Num,signed char String[])
// 返回字符串长度
{
	signed int  Num_Length=0;
    signed char Negative_Flag=0;
	signed char *Point_p=String;                //做换向时用的指针
	signed char *Point_s=String;
    if(Int_Num<0)
	{
		Negative_Flag=1;
		Int_Num=0-Int_Num;
	}
	if(Int_Num==0)
		String[Num_Length++]='0';
	while(Int_Num>0)
	{
	 	String[Num_Length++]=Int_Num%10+'0';
	 	Int_Num=Int_Num/10;
	}
	if(Negative_Flag)
	{
		String[Num_Length++]='-';
	}
    String[Num_Length]='\0';
	Point_p=String+Num_Length-1;                //将P指针指向字符串结束标志之前

	for(;Point_p-Point_s>0;Point_p--,Point_s++) //将字符串中存储的数调头
	{
		*Point_s^=*Point_p;
		*Point_p^=*Point_s;
		*Point_s^=*Point_p;
	}
	return(Num_Length);
}

/*------------------*浮点型转字符串*------------------*/

signed int Float_To_String(float Float_Num,signed char String[])
// Dot_Size为小数点后边保留位数
// 返回字符串长度
{
	signed int  Num_Length=0;
	signed int  Temp_i=0;
	signed char *Point_p=String;                //做换向时用的指针
	signed char *Point_s=String;
	signed char Negative_Flag=0;
	signed long Predot_Num;
	signed long Afterdot_Num;
	float Afterdot_Float;

	if(Float_Num<0)
	{
		Negative_Flag=1;
		Float_Num=0-Float_Num;
	}

	Predot_Num=(signed long)Float_Num;          //将小数点之前的数变为整数
	Afterdot_Float=Float_Num-Predot_Num;        //单独取出小数点之后的数
	for(Temp_i=Dot_Size;Temp_i>0;Temp_i--)
	{
		Afterdot_Float=Afterdot_Float*10;
	}
	Afterdot_Num=(signed long)Afterdot_Float;

	Temp_i=Dot_Size;

	while(Afterdot_Num>0|Temp_i>0)
	{
		Temp_i--;
	 	String[Num_Length++]=Afterdot_Num%10+'0';
	 	Afterdot_Num=Afterdot_Num/10;
	}
	String[Num_Length++]='.';

	if(Predot_Num==0)                           //处理小数点前为0的情况
	{
		String[Num_Length++]='0';
	}

	while(Predot_Num>0)
	{
	 	String[Num_Length++]=Predot_Num%10+'0';
	 	Predot_Num=Predot_Num/10;
	}

	if(Negative_Flag==1)
	{
		String[Num_Length++]='-';
	}
	String[Num_Length]='\0';                    //加上字符串结束标志

	Point_p=String+Num_Length-1;                //将P指针指向字符串结束标志之前

	for(;Point_p-Point_s>0;Point_p--,Point_s++) //将字符串中存储的数调头
	{
		*Point_s^=*Point_p;
		*Point_p^=*Point_s;
		*Point_s^=*Point_p;
	}

	return(Num_Length);
}


/******************************************************/
/********************  生成接口    ********************/
/******************************************************/

/*-----------------*OLED写一个字符串*-----------------*/

void OLED_Write_String(unsigned char x,unsigned char y,signed char String[])
{
  unsigned char Temp_Char=0,Temp_i=0,Temp_j=0;

  while(String[Temp_j]!='\0')
  {
    Temp_Char=String[Temp_j]-32;
    if(y>120)
    {
    	y=0;
    	x++;
    }
    OLED_Set_Pos(y,x);
  	for(Temp_i=0;Temp_i<8;Temp_i++)
  	{
  		OLED_Write_Data(Font_8x16[Temp_Char*16+Temp_i]);
  	}
  	OLED_Set_Pos(y,x+1);
  	for(Temp_i=0;Temp_i<8;Temp_i++)
  	{
  		OLED_Write_Data(Font_8x16[Temp_Char*16+Temp_i+8]);
  	}
  	y+=8;
  	Temp_j++;
  }
}

/*-----------------*OLED写一个字符*-------------------*/

void OLED_Write_Char(unsigned char x,unsigned char y,signed char Asc)
{
	signed char Temp_String[2];
	y=y*8;
	Temp_String[0]=Asc;
	Temp_String[1]='\0';			                  //字母占一个字节
	OLED_Write_String(x,y,Temp_String);	        //显示字母
}

/*-----------------*OLED写一个字符*-------------------*/

void OLED_Write_Draw(unsigned char x,unsigned char y,signed char Asc)
{
	unsigned char Temp_i;
    unsigned char Temp_Char;
	y=y*8;

    Temp_Char=Asc;

    OLED_Set_Pos(y,x);
	for(Temp_i=0;Temp_i<8;Temp_i++)
	{
		OLED_Write_Data(Draw[Temp_Char*16+Temp_i]);
	}
	OLED_Set_Pos(y,x+1);
	for(Temp_i=0;Temp_i<8;Temp_i++)
	{
		OLED_Write_Data(Draw[Temp_Char*16+Temp_i+8]);
	}
}

/*----------------*OLED写一个整型数据*----------------*/

void OLED_Write_Int(unsigned char x,unsigned char y,signed int Number)
{
	signed char Temp_Buf[17];
    (void)Int_To_String(Number,Temp_Buf);
    OLED_Write_String(x,y,Temp_Buf);
}

/*---------------*OLED写一个浮点型数据*---------------*/

void OLED_Write_Float(unsigned char x,unsigned char y,float Number)
{
	signed char Temp_Buf[17];
    (void)Float_To_String(Number,Temp_Buf);
    OLED_Write_String(x,y,Temp_Buf);
}


/*-----------------*OLED写七位字符串*-----------------*/

void OLED_Write_String_7(unsigned char y,unsigned char x,signed char String[])
{
	unsigned char Temp_Char=0,Temp_i=0,Temp_j=0,Temp_k=0;
 // unsigned char Over_Flag=0;
    unsigned char String_Length=0;

    while(String[String_Length]!='\0')
    {
    	String_Length++;
    }

    if(String_Length>7)
    {
    	String_Length=7;
    }

    while(Temp_j<7)
    {
    	String_Length++;
        if(String_Length>=8)
        {
        	Temp_Char=String[Temp_k]-32;
            OLED_Set_Pos(x,y);
    	    for(Temp_i=0;Temp_i<8;Temp_i++)
    	    {
    	    	OLED_Write_Data(Font_8x16[Temp_Char*16+Temp_i]);
    	    }
    	    OLED_Set_Pos(x,y+1);
    	    for(Temp_i=0;Temp_i<8;Temp_i++)
    	    {
    	    	OLED_Write_Data(Font_8x16[Temp_Char*16+Temp_i+8]);
    	    }
    	    Temp_k++;
        }
        else
        {
        	OLED_Set_Pos(x,y);
    	    for(Temp_i=0;Temp_i<8;Temp_i++)
    	    {
    	    	OLED_Write_Data(Font_8x16[0]);
    	    }
    	    OLED_Set_Pos(x,y+1);
    	    for(Temp_i=0;Temp_i<8;Temp_i++)
    	    {
    	    	OLED_Write_Data(Font_8x16[0]);
    	    }
        }
  	    x+=8;
  	    Temp_j++;
    }
}
//--------------------OLED写七位字符串--------------------//
/*
void Dis_Head_Data(float Data_Left,float Data_Mid,float Data_Right)
{
  signed char Temp_Buf[17];

  OLED_Write_Int(0,0,Data_Left);
  OLED_Write_Int(0,40,Data_Mid);
  OLED_Write_Int(0,80,Data_Right);

}*/
/*---------------------*清空位置*---------------------*/

void Position_Clear(unsigned char Position)
{
	unsigned char Temp_i;
    unsigned char Temp_y,Temp_x;
    switch(Position)
    {
    case 1:Temp_x=8,Temp_y=2;break;
    case 2:Temp_x=72,Temp_y=2;break;
    case 3:Temp_x=8,Temp_y=4;break;
    case 4:Temp_x=72,Temp_y=4;break;
    case 5:Temp_x=8,Temp_y=6;break;
    case 6:Temp_x=72,Temp_y=6;break;
    default:break;
    }

    OLED_Set_Pos(Temp_x,Temp_y);
    for(Temp_i=0;Temp_i<56;Temp_i++)
    {
    	OLED_Write_Data(0x00);
    }
    OLED_Set_Pos(Temp_x,Temp_y+1);
    for(Temp_i=0;Temp_i<56;Temp_i++)
    {
    	OLED_Write_Data(0x00);
    }
}

/*--------------------*屏幕头显示*--------------------*/

void Dis_Head(signed char String[])
{
	unsigned char Temp_Char=0,Temp_i=0,Temp_j=0,Position_x=32;
    unsigned char Over_Flag=0;
    unsigned char String_Length=0;
    unsigned char Begin=0;
 // unsigned char Loop_i;

    while(String[String_Length]!='\0')
    {
    	String_Length++;
    }

    if(String_Length>10)
    {
    	Begin=0;
    }
    else
    {
    	Begin=(signed char)((10.0-String_Length)/2);
    }

    while(Temp_j<10)
    {
    	if(Temp_j<Begin)
        {
    		OLED_Set_Pos(Position_x,0);
    	    for(Temp_i=0;Temp_i<8;Temp_i++)
    	    {
    	    	OLED_Write_Data(Font_8x16[0]);
    	    }
    	    OLED_Set_Pos(Position_x,1);
    	    for(Temp_i=0;Temp_i<8;Temp_i++)
    	    {
    	    	OLED_Write_Data(Font_8x16[0]);
    	    }
        }
        else
        {
        	Temp_Char=String[Temp_j-Begin]-32;

            if(String[Temp_j-Begin]=='\0')
            {
            	Over_Flag=1;
            }

            if(Over_Flag==0)
            {
            	OLED_Set_Pos(Position_x,0);
      	        for(Temp_i=0;Temp_i<8;Temp_i++)
      	        {
      	        	OLED_Write_Data(Font_8x16[Temp_Char*16+Temp_i]);
      	        }
      	        OLED_Set_Pos(Position_x,1);
      	        for(Temp_i=0;Temp_i<8;Temp_i++)
      	        {
      	        	OLED_Write_Data(Font_8x16[Temp_Char*16+Temp_i+8]);
      	        }
            }
            else
            {
            	OLED_Set_Pos(Position_x,0);
      	        for(Temp_i=0;Temp_i<8;Temp_i++)
      	        {
      	        	OLED_Write_Data(Font_8x16[0]);
      	        }
      	        OLED_Set_Pos(Position_x,1);
      	        for(Temp_i=0;Temp_i<8;Temp_i++)
      	        {
      	        	OLED_Write_Data(Font_8x16[0]);
      	        }
            }
         }
         Position_x+=8;
         Temp_j++;
    }
}

/*--------------------*显示字符串*--------------------*/

void Dis_String(unsigned char Position,signed char String[])
{
  switch(Position)
  {
  case 1:OLED_Write_String_7(2,8,String);break;
  case 2:OLED_Write_String_7(2,72,String);break;
  case 3:OLED_Write_String_7(4,8,String);break;
  case 4:OLED_Write_String_7(4,72,String);break;
  case 5:OLED_Write_String_7(6,8,String);break;
  case 6:OLED_Write_String_7(6,72,String);break;
  default:break;
  }
}

/*--------------------*显示整型数*--------------------*/

void Dis_Int(unsigned char Position,signed int Number)
{
	signed char Temp_Buf[17];
    (void)Int_To_String(Number,Temp_Buf);
    Dis_String(Position,Temp_Buf);
}

/*--------------------*显示浮点型*--------------------*/

void Dis_Float(unsigned char Position,float Number)
{
	signed char Temp_Buf[17];
    (void)Float_To_String(Number,Temp_Buf);
    Dis_String(Position,Temp_Buf);
}


/*-------------------*列表更新显示*-------------------*/

void Paint_Fresh(float New_Data,float Paint_Ave,float Paint_Margin)
// 将某个数据以列表刷新的形式显示出来
{
	static unsigned char Temp_i;
    unsigned char Cross1;
    unsigned char Temp_Data;

    Temp_Data=(signed char)(22.0/Paint_Margin*(New_Data-Paint_Ave)+26);

  /*if(Temp_i>120)
  {
    Temp_i=0;
    OLED_Clear();
  }       */
    for(Cross1=0;Cross1<6;Cross1++)
    {
    	if(Temp_Data>>3==Cross1)
        {
    		OLED_Set_Pos(Temp_i,7-Cross1);
            OLED_Write_Data(Change_To_Bit[ Temp_Data&0x07 ]);
        }
    }
    Temp_i++;
}

/*---------------------*列表移动*---------------------*/

void List_Move(signed char New_Data)
// 对数组进行移位
{
	static signed int Temp_i;
    signed int Temp_j;

    if(Temp_i<128)
    {
    	Temp_List[Temp_i]=New_Data;
    }
    else
    {
    	for(Temp_j=0;Temp_j<127;Temp_j++)
        {
    		Temp_List[Temp_j]=Temp_List[Temp_j+1];
        }
        Temp_List[127]=New_Data;
    }
    if(Temp_i>=128)
    {
    	Temp_i=128;
    }
    else
    {
    	Temp_i++;
    }
}
/*-------------------*显示列表图形*-------------------*/

void List_Paint(void)
// 将Temp_List列表里面的数据用一整幅图画出来
{
	unsigned char Temp_i;
    unsigned char Cross1;

    for(Cross1=0;Cross1<6;Cross1++)
    {
    	OLED_Set_Pos(0,7-Cross1);
        for(Temp_i=0;Temp_i<128;Temp_i++)
        {
        	if(Temp_List[Temp_i]>>3==Cross1)
            {
        		OLED_Write_Data(Change_To_Bit[ Temp_List[Temp_i]&0x07 ]);
            }
            else
            {
            	OLED_Write_Data(0x00);
            }
        }
    }
}

/*-------------------*递推显示数据*-------------------*/


void Paint_List(float New_Data,float Paint_Ave,float Paint_Margin)
// 将某个数据以列表刷新的形式显示出来
{
	unsigned char Temp_Data;

    Temp_Data=(signed char)(22.0/Paint_Margin*(New_Data-Paint_Ave)+26);
    List_Move(Temp_Data);
    List_Paint();
}


/*-------------------*画出图像竖轴*-------------------*/

void Paint_Axis(void)
// 画出图像竖轴
{
	signed char Temp_i,Temp_j;
    for(Temp_j=0;Temp_j<6;Temp_j++)
    {
    	OLED_Set_Pos(0,2+Temp_j);
        OLED_Write_Data(0x00);
        if(Temp_j==0)
        {
        	OLED_Write_Data(0xf0);
        }
        else
        {
        	OLED_Write_Data(0xff);
        }
        for(Temp_i=0;Temp_i<6;Temp_i++)
        {
        	OLED_Write_Data(0x00);
        }
     }

    OLED_Set_Pos(2,5);
    for(Temp_i=0;Temp_i<4;Temp_i++)
    {
    	OLED_Write_Data(0x02);
    }
}

/**********************************************************/
/*******************     这有五个字     *******************/
/**********************************************************/

//-----------------------原始图转换-----------------------//


//-----------------------原始图转换-----------------------//

//void Image_Transform(void)
//// 如果摄像头正装，就使用[0][0]，并且++
//// 如果反装，[Cross-1][Row-1]，并且--
//{
//  unsigned char Temp_Bit;
//  unsigned char Temp_i,Temp_j;
//  unsigned char *Result_Point,*Image_Point;
//
////  Image_Point=&Image[0][0];
//  Image_Point=&Image[Cross-1][Row-1];
//
//  for(Temp_i=0;Temp_i<Cross;Temp_i++)
//  {
//    Result_Point=&Paint_Buffer[Temp_i>>3][0];
//    Temp_Bit=Change_To_Bit_2[Temp_i&0x07];
//
//    for(Temp_j=0;Temp_j<128;Temp_j++)
//    {
//      if(((*Image_Point)&(CAMERA_DATA_PIN))==0)
//      *Result_Point&=(~Temp_Bit);
//      else
//      *Result_Point|=(Temp_Bit);
//
////      if((Temp_j==127-(midline[Temp_i])))
////      *Result_Point&=(~Temp_Bit);
//
////    Image_Point+=1;
//      Image_Point-=1;
//      Result_Point++;
//    }
//  }
//  Draw_BMP(0,0,Row-1,(Cross)/8-1,(void*)Paint_Buffer);
//}

//------------------------边界转换------------------------//
void Border_Transform(signed int *Border)
{
	unsigned char Temp_Cross;
    unsigned char Temp_Bit,Anti_Bit;   // 位操作
    unsigned int Temp_Count;// 计数变量
    unsigned char *Paint_Point;     // 数组指针

    for(Temp_Cross=0;Temp_Cross<Cross;Temp_Cross++)
    {
    	unsigned char Anti_Treat;

        Temp_Bit=Change_To_Bit[Temp_Cross&0x07]; // 记录开始点
        Anti_Bit=~Temp_Bit;
        Anti_Treat=(unsigned char)((Cross-1-Temp_Cross)>>3);

        Paint_Point=&(Paint_Buffer[Anti_Treat][0]);

        for(Temp_Count=0;Temp_Count<=*Border;Temp_Count+=2)
        {
        	(*Paint_Point)&=Anti_Bit;
            Paint_Point++;
        }

        for(;Temp_Count<*(Border+Cross);Temp_Count+=2)
        {
        	(*Paint_Point)|=Temp_Bit;
            Paint_Point++;
        }
        for(;Temp_Count<256;Temp_Count+=2)
        {
        	(*Paint_Point)&=Anti_Bit;
            Paint_Point++;
        }
        Border++;
     }
}

//------------------------添加中线------------------------//

void Add_Line_Transform(signed int *Add_Line)
{
	unsigned char Temp_Cross;
    for(Temp_Cross=0;Temp_Cross<Cross;Temp_Cross++)
    {
    	Paint_Buffer[(Cross-Temp_Cross-1)>>3][*(Add_Line+Temp_Cross)
        #if Display_Interval!=1
            /Display_Interval
        #endif
        ]&=(~Change_To_Bit[Temp_Cross&0x07]);
    }
}

//----------------------只画一条直线----------------------//

void Line_Transform(signed int *Dis_Line)
{
	unsigned char Temp_Count;
    signed int Temp_Buffer[Cross<<1];
    for(Temp_Count=0;Temp_Count<Cross;Temp_Count++)
    {
    	Temp_Buffer[Temp_Count]=0;
        Temp_Buffer[Temp_Count+Cross]=Dis_Line[Temp_Count];
    }
    Border_Transform(Temp_Buffer);
}

//----------------------画出平行虚线----------------------//

void Add_Cross(unsigned char Temp_Add_Cross)
{
	unsigned char Temp_Count;
    unsigned char Temp_Bit;
    unsigned char *Temp_Point;
    if(Temp_Add_Cross>63)
    {
    	Temp_Add_Cross=63;
    }
    else if(Temp_Add_Cross<1)
    {
    	Temp_Add_Cross=0;
    }

    Temp_Point=&Paint_Buffer[(Cross-Temp_Add_Cross-1)>>3][0];
    Temp_Bit=Change_To_Bit[Temp_Add_Cross&0x07]; // 记录开始点

    for(Temp_Count=0;Temp_Count<128;Temp_Count+=2)
    {
    	*Temp_Point|=Temp_Bit;
        Temp_Point++;
        *Temp_Point&=~Temp_Bit;
        Temp_Point++;
    }
}

void Add_Cross_2(unsigned char Temp_Add_Cross)
{
	unsigned char Temp_Count;
    unsigned char Temp_Bit;
    unsigned char *Temp_Point;
    if(Temp_Add_Cross>63)
    {
    	Temp_Add_Cross=63;
    }
    else if(Temp_Add_Cross<1)
    {
    	Temp_Add_Cross=0;
    }
    Temp_Point=&Paint_Buffer[(Cross-Temp_Add_Cross-1)>>3][0];
    Temp_Bit=Change_To_Bit[Temp_Add_Cross&0x07]; // 记录开始点

    for(Temp_Count=0;Temp_Count<128;Temp_Count+=1)
    {
    	*Temp_Point|=Temp_Bit;
        Temp_Point++;
    }
}

//------------------------图像显示------------------------//

void Image_Display(void)  //在液晶上显示图像
{
	unsigned char Temp_i,Temp_j;
    unsigned char Temp_Row;
    Temp_Row=Cross>>3;

    for(Temp_i=0;Temp_i<Temp_Row;Temp_i++)
    {
    	OLED_Set_Pos(0,Temp_i+2);
       for(Temp_j=0;Temp_j<128;Temp_j++)
       {
    	 //  OLED_Write_Data(Image[Temp_i][Temp_j]);
       }
    }
}


/**********************************************************/
/*******************     这有五个字     *******************/
/**********************************************************/

//-----------------------显示控制量-----------------------//

void Dis_Control(float New_Data,float Err_Ave,float Err_Margin)
{
	unsigned char Temp_Count;
    signed int Temp_Which;
    for(Temp_Count=0;Temp_Count<128;Temp_Count++)
    {
    	if(Temp_Count%16!=15)
  	    {
    		Paint_Buffer[(Cross>>3)-1][Temp_Count]=0;
  	    }
        else
  	    {
        	Paint_Buffer[(Cross>>3)-1][Temp_Count]=0x80;
  	    }
    }
    Paint_Buffer[(Cross>>3)-1][63]=0xe0;
    Temp_Which=(signed int)(63.0/Err_Margin*(New_Data-Err_Ave)+63);
    if(Temp_Which>=128)
    {
    	Temp_Which=127;
    }
    else if(Temp_Which<0)
    {
    	Temp_Which=0;
    }
    Paint_Buffer[(Cross>>3)-1][Temp_Which]=0xfc;//11111100
}
/*****************************************************************************
 函 数 名  : OLED_PrintImage
 功能描述  : 将图像显示出来
 输入参数  : u16 *Image_data     二维图像数组的地址
             u8 RowNum    二维图像的行数0~63
             u8 ColumnNum 二维图像的列数0~127
 输出参数  : none
 返 回 值  : none
*****************************************************************************/
void OLED_PrintImage(uint16_t *Image_data, uint8_t RowNum, uint8_t ColumnNum)
{
	uint8_t Data;
	uint8_t i,j,k,m,n;
	uint8_t RowTemp;

    m = RowNum >> 3;   //计算图片行数以8位为一组完整的组数
    n = RowNum % 8;    //计算分完组后剩下的行数

    for(i = 0; i < m; i++) //完整组行扫描
    {
        OLED_Set_Pos(0,(uint8_t)i);
        RowTemp = i << 3;    //计算当前所在行的下标
        for(j = 0; j < ColumnNum; j++) //列扫描
        {
            Data = 0;
            for(k = 0; k < 8; k++) //在i组中对这8行扫描
            {
                Data = Data >> 1;
                if((Image_data + (RowTemp + k) * ColumnNum)[j] == 0)
                {
                    Data = Data | 0x80;
                }
            }
            OLED_Write_Data(Data);
        }
    }

    OLED_Set_Pos(0,(uint8_t)i); //设置剩下的行显示的起始坐标
    RowTemp = i << 3;       //计算当前所在行的下标
    for(j = 0; j < ColumnNum; j++) //列扫描
    {
        Data = 0;
        for(k = 0; k < n; k++) //对剩下的行扫描
        {
            Data = Data >> 1;
            if((Image_data + (RowTemp + k) * ColumnNum)[j] == 0)
            {
                Data = Data | 0x80;
            }

        }
        Data = Data >> (8 - n);
        OLED_Write_Data(Data);
    }

    return;
}

/********************************************
 * 显示CCD图像
 */
void Delay(void)
{
	long i;
	for(i=0;i<3000000;i++)
	{
		asm("nop");
	}
}

void Draw_edge(uint8_t y1,uint8_t y2,uint8_t x)
{
	uint8_t Data_transform[8] = {1,2,4,8,16,32,64,128};
	uint8_t group1,group2;
	uint8_t number1,number2;
	uint8_t data_temp;
	uint8_t temp,i;

	if (y1 < y2)
	{
		temp = y1; y1 = y2; y2 = temp; x++;
	}
	group1 = 7 - (y1 / 8);
	number1 = y1 % 8;
	group2 = 7 - (y2 / 8);
	number2 = y2 % 8;

	if (group1 == group2)
	{
		data_temp = 0;
		for(i=number2;i<=number1;i++)
		{
			data_temp += Data_transform[7-(i-1)];
		}
		OLED_Set_Pos(x,group1);
		OLED_Write_Data(data_temp);
	}
	else
	{
		data_temp = 0;
		for(i=number2;i<=8;i++)
		{
			data_temp += Data_transform[7-(i-1)];
		}
		OLED_Set_Pos(x,group2);
		OLED_Write_Data(data_temp);
		for(i=group1+1;i<=group2;i++)
		{
			OLED_Set_Pos(x,i);
			OLED_Write_Data(255);
		}
		data_temp = 0;
		for(i=number1;i>=1;i--)
		{
			data_temp += Data_transform[7-(i-1)];
		}
		OLED_Set_Pos(x,group1);
		OLED_Write_Data(data_temp);
	}

}

void Image_Transform(void)
// 如果摄像头正装，就使用[0][0]，并且++
// 如果反装，[Cross-1][Row-1]，并且--
{
	unsigned char Temp_Bit;
    unsigned char Temp_i,Temp_j;
    unsigned char *Result_Point,*Image_Point;

    Image_Point=&Image[0][0];
    //Image_Point=&Image[Cross-1][Row-1];

    for(Temp_i=0;Temp_i<Cross;Temp_i++)
    {

    	Result_Point=&Paint_Buffer[Temp_i>>3][0];
        Temp_Bit=Change_To_Bit_2[Temp_i&0x07];

        for(Temp_j=0;Temp_j<128;Temp_j++)
        {
        	if(((*Image_Point)&0x01)==0)
            {
        		*Result_Point|=(Temp_Bit);
            }
            else
            {
            	*Result_Point&=(~Temp_Bit);
            }

             Image_Point++;

            Result_Point++;
        }
    }

    Draw_BMP(0,0,Row-1,(Cross)/8-1,(void*)Paint_Buffer);
}

void Draw_BMP(uint16_t x0,uint16_t y0,uint16_t x1,uint16_t y1,uint8_t bmp[])//显示摄像头图像
{
	  uint32_t ii=0;
	  uint16_t x,y;
	  if(y1%8==0)
		  y=y1/8;
	  else
		  y=y1/8+1;
	  for(y=y0;y<=y1;y++)
	  {
		  OLED_Set_Pos(x0,y);
		  for(x=x0;x<=x1;x++)
		  {
			  OLED_Write_Data(~bmp[ii++]);
		  }
	  }
}
/*void OLED_DrawPoint(uint8_t x,uint8_t y,uint8_t t)
{
	uint8_t pos,bx,temp=0;
	if(x>127||y>63)return;//超出范围了.
	pos=7-y/8;
	bx=y%8;
	temp=1<<(7-bx);
	if(t)OLED_GRAM[x][pos]|=temp;
	else OLED_GRAM[x][pos]&=~temp;
}*/
